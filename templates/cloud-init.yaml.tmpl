#cloud-config
# Generated by spinup - DO NOT EDIT
#
# This template is used to bootstrap GPU instances with:
# - WireGuard VPN for secure access
# - Ollama for LLM serving
# - Deadman switch for automatic cleanup
# - Firewall rules for security
#
# Template variables:
#   .WireGuard.ServerPrivateKey - Base64-encoded WireGuard server private key
#   .WireGuard.ClientPublicKey  - Base64-encoded WireGuard client public key
#   .WireGuard.ServerAddress    - Server IP address with CIDR (default: 10.13.37.1/24)
#   .WireGuard.ListenPort       - WireGuard UDP port (default: 51820)
#   .WireGuard.ClientAllowedIPs - Client allowed IPs (default: 10.13.37.2/32)
#   .Deadman.TimeoutSeconds     - Deadman timeout in seconds (default: 36000 = 10h)
#   .Provider                   - Provider name (vast, lambda, runpod, coreweave, paperspace)
#   .InstanceID                 - Provider-specific instance ID
#   .Model                      - Ollama model to pull (e.g., qwen2.5-coder:32b)
#   .APIKey                     - Provider API key for self-termination

package_update: true
package_upgrade: false

packages:
  - docker.io
  - wireguard-tools
  - jq
  - curl

write_files:
  - path: /etc/wireguard/wg0.conf
    permissions: '0600'
    content: |
      [Interface]
      PrivateKey = {{ .WireGuard.ServerPrivateKey }}
      Address = {{ .WireGuard.ServerAddress }}
      ListenPort = {{ .WireGuard.ListenPort }}

      [Peer]
      PublicKey = {{ .WireGuard.ClientPublicKey }}
      AllowedIPs = {{ .WireGuard.ClientAllowedIPs }}

  - path: /usr/local/bin/deadman.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      TIMEOUT_SECONDS={{ .Deadman.TimeoutSeconds }}
      HEARTBEAT_FILE=/tmp/spinup-heartbeat
      PROVIDER={{ .Provider }}
      INSTANCE_ID={{ .InstanceID }}

      touch $HEARTBEAT_FILE

      while true; do
          sleep 60
          if [ $(($(date +%s) - $(stat -c %Y $HEARTBEAT_FILE))) -gt $TIMEOUT_SECONDS ]; then
              echo "Deadman triggered"
              {{- if eq .Provider "vast" }}
              curl -X DELETE "https://console.vast.ai/api/v0/instances/${INSTANCE_ID}/" \
                  -H "Authorization: Bearer {{ .APIKey }}"
              {{- else if eq .Provider "lambda" }}
              curl -X POST "https://cloud.lambdalabs.com/api/v1/instance-operations/terminate" \
                  -H "Authorization: Bearer {{ .APIKey }}" \
                  -d '{"instance_ids": ["'${INSTANCE_ID}'"]}'
              {{- else if eq .Provider "runpod" }}
              curl -X POST "https://api.runpod.io/graphql" \
                  -H "Authorization: Bearer {{ .APIKey }}" \
                  -H "Content-Type: application/json" \
                  -d '{"query":"mutation { podTerminate(input: {podId: \"'${INSTANCE_ID}'\"}) { id } }"}'
              {{- else if eq .Provider "coreweave" }}
              curl -X DELETE "https://api.coreweave.com/v1/instances/${INSTANCE_ID}" \
                  -H "Authorization: Bearer {{ .APIKey }}"
              {{- else if eq .Provider "paperspace" }}
              curl -X POST "https://api.paperspace.io/machines/${INSTANCE_ID}/destroyMachine" \
                  -H "x-api-key: {{ .APIKey }}"
              {{- end }}
              shutdown -h now
          fi
      done

  - path: /etc/systemd/system/deadman.service
    content: |
      [Unit]
      Description=Continueplz Deadman Switch
      After=network.target

      [Service]
      ExecStart=/usr/local/bin/deadman.sh
      Restart=always

      [Install]
      WantedBy=multi-user.target

  - path: /etc/spinup-instance
    content: |
      PROVIDER={{ .Provider }}
      INSTANCE_ID={{ .InstanceID }}

  - path: /usr/local/bin/spot-interrupt-monitor.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Spot Interruption Monitor for spinup
      # Monitors provider metadata service for termination notices
      # Serves interruption status via HTTP on port 51822

      PORT=51822
      PROVIDER="{{ .Provider }}"
      INTERRUPT_FILE="/tmp/spinup-interrupted"
      LOG_FILE="/var/log/spinup-spot-monitor.log"

      log() {
          echo "$(date -Iseconds) $1" >> "$LOG_FILE"
      }

      log "Starting spot interruption monitor for provider: $PROVIDER"

      # Provider-specific metadata service URLs and detection logic
      check_interruption() {
          case "$PROVIDER" in
              vast)
                  # Vast.ai uses file marker for interruption
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
              runpod)
                  # RunPod uses AWS-style metadata service for spot termination
                  TERMINATION_TIME=$(curl -sf --connect-timeout 2 \
                      http://169.254.169.254/latest/meta-data/spot/termination-time 2>/dev/null)
                  if [ -n "$TERMINATION_TIME" ] && [ "$TERMINATION_TIME" != "null" ]; then
                      echo "$TERMINATION_TIME" > /tmp/termination-time
                      return 0
                  fi
                  return 1
                  ;;
              coreweave)
                  # CoreWeave uses Kubernetes-style preemption notice
                  PREEMPTED=$(curl -sf --connect-timeout 2 \
                      http://169.254.169.254/v1/spot/preemption-notice 2>/dev/null)
                  if [ -n "$PREEMPTED" ] && [ "$PREEMPTED" != "null" ]; then
                      return 0
                  fi
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
              lambda|paperspace)
                  # Lambda and Paperspace don't support spot instances
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
              *)
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
          esac
      }

      get_termination_time() {
          if [ -f /tmp/termination-time ]; then
              cat /tmp/termination-time
          else
              echo ""
          fi
      }

      get_reason() {
          case "$PROVIDER" in
              vast)
                  echo "capacity_reclaimed"
                  ;;
              runpod|coreweave)
                  echo "preempted"
                  ;;
              *)
                  echo "unknown"
                  ;;
          esac
      }

      # Background process to monitor for interruption
      (
          while true; do
              if check_interruption; then
                  if [ ! -f "$INTERRUPT_FILE" ]; then
                      TERMINATION_TIME=$(get_termination_time)
                      REASON=$(get_reason)
                      log "INTERRUPTION DETECTED: reason=$REASON termination_time=$TERMINATION_TIME"
                      echo "{\"reason\":\"$REASON\",\"termination_time\":\"$TERMINATION_TIME\"}" > "$INTERRUPT_FILE"
                  fi
              fi
              sleep 5
          done
      ) &
      MONITOR_PID=$!
      log "Background monitor started with PID: $MONITOR_PID"

      # HTTP server to serve interruption status
      while true; do
          if [ -f "$INTERRUPT_FILE" ]; then
              INTERRUPT_DATA=$(cat "$INTERRUPT_FILE")
              REASON=$(echo "$INTERRUPT_DATA" | jq -r '.reason // "unknown"' 2>/dev/null || echo "unknown")
              TERM_TIME=$(echo "$INTERRUPT_DATA" | jq -r '.termination_time // ""' 2>/dev/null || echo "")
              RESPONSE_BODY="{\"interrupted\":true,\"reason\":\"$REASON\",\"termination_time\":\"$TERM_TIME\",\"message\":\"Spot instance interruption detected\"}"
          else
              RESPONSE_BODY='{"interrupted":false}'
          fi

          CONTENT_LENGTH=${#RESPONSE_BODY}
          RESPONSE="HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: $CONTENT_LENGTH\r\nConnection: close\r\n\r\n$RESPONSE_BODY"

          echo -e "$RESPONSE" | nc -l -p $PORT -q 1 2>/dev/null | while read line; do
              if echo "$line" | grep -q "GET /interrupt-status"; then
                  log "Received interrupt status request"
              fi
          done
      done

  - path: /etc/systemd/system/spot-interrupt-monitor.service
    content: |
      [Unit]
      Description=Continueplz Spot Interruption Monitor
      After=network.target wg-quick@wg0.service

      [Service]
      ExecStart=/usr/local/bin/spot-interrupt-monitor.sh
      Restart=always

      [Install]
      WantedBy=multi-user.target

runcmd:
  # Firewall
  - ufw default deny incoming
  - ufw default allow outgoing
  - ufw allow 51820/udp
  - ufw enable

  # WireGuard
  - systemctl enable wg-quick@wg0
  - systemctl start wg-quick@wg0

  # Allow Ollama and spot interrupt monitor only via WireGuard
  - ufw allow in on wg0 to any port 11434
  - ufw allow in on wg0 to any port 22
  - ufw allow in on wg0 to any port 51822

  # Docker setup
  - systemctl enable docker
  - systemctl start docker

  # NVIDIA Container Toolkit
  - curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg
  - curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
  - apt-get update
  - apt-get install -y nvidia-container-toolkit
  - nvidia-ctk runtime configure --runtime=docker
  - systemctl restart docker

  # Start Ollama
  - docker run -d --gpus all -v ollama:/root/.ollama -p 10.13.37.1:11434:11434 --name ollama --restart unless-stopped ollama/ollama

  # Wait and pull model
  - sleep 10
  - until curl -s http://10.13.37.1:11434/api/tags > /dev/null; do sleep 2; done
  - docker exec ollama ollama pull {{ .Model }}

  # Start deadman
  - systemctl enable deadman
  - systemctl start deadman

  # Start spot interrupt monitor
  - systemctl enable spot-interrupt-monitor
  - systemctl start spot-interrupt-monitor

  # Signal ready
  - touch /tmp/spinup-ready
