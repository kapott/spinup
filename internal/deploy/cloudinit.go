// Package deploy provides deployment orchestration for continueplz.
package deploy

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/tmeurs/continueplz/internal/wireguard"
)

// CloudInitParams contains all parameters needed to generate a cloud-init configuration.
type CloudInitParams struct {
	// WireGuard configuration
	WireGuard WireGuardParams

	// Deadman switch configuration
	Deadman DeadmanParams

	// Provider information
	Provider   string
	InstanceID string

	// Model to deploy
	Model string

	// API key for deadman self-termination (provider-specific)
	APIKey string
}

// WireGuardParams contains WireGuard-specific parameters for cloud-init.
type WireGuardParams struct {
	// ServerPrivateKey is the base64-encoded WireGuard private key for the server.
	ServerPrivateKey string
	// ClientPublicKey is the base64-encoded WireGuard public key of the client.
	ClientPublicKey string
	// ListenPort is the UDP port for WireGuard (default: 51820).
	ListenPort int
	// ServerAddress is the WireGuard IP for the server (default: 10.13.37.1/24).
	ServerAddress string
	// ClientAllowedIPs is the CIDR range for the client (default: 10.13.37.2/32).
	ClientAllowedIPs string
}

// DeadmanParams contains deadman switch configuration.
type DeadmanParams struct {
	// TimeoutSeconds is the deadman switch timeout in seconds.
	// If no heartbeat is received within this time, the instance self-terminates.
	TimeoutSeconds int
}

// NewCloudInitParams creates a CloudInitParams with default values.
// The caller must set WireGuard.ServerPrivateKey, WireGuard.ClientPublicKey,
// Provider, InstanceID, Model, and APIKey.
func NewCloudInitParams() *CloudInitParams {
	return &CloudInitParams{
		WireGuard: WireGuardParams{
			ListenPort:       wireguard.DefaultListenPort,
			ServerAddress:    wireguard.ServerAddress,
			ClientAllowedIPs: wireguard.ClientAllowedIPs,
		},
		Deadman: DeadmanParams{
			TimeoutSeconds: 36000, // 10 hours default
		},
	}
}

// CloudInitParamsFromServerConfig creates CloudInitParams from a WireGuard ServerConfig.
// This is a convenience function for when you already have a ServerConfig.
func CloudInitParamsFromServerConfig(serverCfg *wireguard.ServerConfig, provider, instanceID, model, apiKey string, deadmanTimeout int) *CloudInitParams {
	params := NewCloudInitParams()

	if serverCfg != nil {
		params.WireGuard.ServerPrivateKey = serverCfg.ServerPrivateKey
		params.WireGuard.ClientPublicKey = serverCfg.ClientPublicKey
		if serverCfg.ListenPort > 0 {
			params.WireGuard.ListenPort = serverCfg.ListenPort
		}
		if serverCfg.ServerAddress != "" {
			params.WireGuard.ServerAddress = serverCfg.ServerAddress
		}
		if serverCfg.ClientAllowedIPs != "" {
			params.WireGuard.ClientAllowedIPs = serverCfg.ClientAllowedIPs
		}
	}

	params.Provider = provider
	params.InstanceID = instanceID
	params.Model = model
	params.APIKey = apiKey

	if deadmanTimeout > 0 {
		params.Deadman.TimeoutSeconds = deadmanTimeout
	}

	return params
}

// Validate validates the CloudInitParams.
func (p *CloudInitParams) Validate() error {
	if p.WireGuard.ServerPrivateKey == "" {
		return fmt.Errorf("WireGuard server private key is required")
	}
	if p.WireGuard.ClientPublicKey == "" {
		return fmt.Errorf("WireGuard client public key is required")
	}
	if p.Provider == "" {
		return fmt.Errorf("provider is required")
	}
	if p.Model == "" {
		return fmt.Errorf("model is required")
	}
	// InstanceID can be empty for some providers during initial creation
	// APIKey can be empty if we don't want self-termination capability

	// Validate provider is known
	validProviders := map[string]bool{
		"vast":       true,
		"lambda":     true,
		"runpod":     true,
		"coreweave":  true,
		"paperspace": true,
	}
	if !validProviders[strings.ToLower(p.Provider)] {
		return fmt.Errorf("unknown provider: %s (valid: vast, lambda, runpod, coreweave, paperspace)", p.Provider)
	}

	return nil
}

// cloudInitTemplate is the embedded template for cloud-init configuration.
// This matches PRD Section 10.2 exactly.
const cloudInitTemplate = `#cloud-config
# Generated by continueplz - DO NOT EDIT

package_update: true
package_upgrade: false

packages:
  - docker.io
  - wireguard-tools
  - jq
  - curl

write_files:
  - path: /etc/wireguard/wg0.conf
    permissions: '0600'
    content: |
      [Interface]
      PrivateKey = {{ .WireGuard.ServerPrivateKey }}
      Address = {{ .WireGuard.ServerAddress }}
      ListenPort = {{ .WireGuard.ListenPort }}

      [Peer]
      PublicKey = {{ .WireGuard.ClientPublicKey }}
      AllowedIPs = {{ .WireGuard.ClientAllowedIPs }}

  - path: /usr/local/bin/deadman.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      TIMEOUT_SECONDS={{ .Deadman.TimeoutSeconds }}
      HEARTBEAT_FILE=/tmp/continueplz-heartbeat
      PROVIDER={{ .Provider }}
      INSTANCE_ID={{ .InstanceID }}

      touch $HEARTBEAT_FILE

      while true; do
          sleep 60
          if [ $(($(date +%s) - $(stat -c %Y $HEARTBEAT_FILE))) -gt $TIMEOUT_SECONDS ]; then
              echo "Deadman triggered"
              {{- if eq .Provider "vast" }}
              curl -X DELETE "https://console.vast.ai/api/v0/instances/${INSTANCE_ID}/" \
                  -H "Authorization: Bearer {{ .APIKey }}"
              {{- else if eq .Provider "lambda" }}
              curl -X POST "https://cloud.lambdalabs.com/api/v1/instance-operations/terminate" \
                  -H "Authorization: Bearer {{ .APIKey }}" \
                  -d '{"instance_ids": ["'${INSTANCE_ID}'"]}'
              {{- else if eq .Provider "runpod" }}
              curl -X POST "https://api.runpod.io/graphql" \
                  -H "Authorization: Bearer {{ .APIKey }}" \
                  -H "Content-Type: application/json" \
                  -d '{"query":"mutation { podTerminate(input: {podId: \"'${INSTANCE_ID}'\"}) { id } }"}'
              {{- else if eq .Provider "coreweave" }}
              curl -X DELETE "https://api.coreweave.com/v1/instances/${INSTANCE_ID}" \
                  -H "Authorization: Bearer {{ .APIKey }}"
              {{- else if eq .Provider "paperspace" }}
              curl -X POST "https://api.paperspace.io/machines/${INSTANCE_ID}/destroyMachine" \
                  -H "x-api-key: {{ .APIKey }}"
              {{- end }}
              shutdown -h now
          fi
      done

  - path: /etc/systemd/system/deadman.service
    content: |
      [Unit]
      Description=Continueplz Deadman Switch
      After=network.target

      [Service]
      ExecStart=/usr/local/bin/deadman.sh
      Restart=always

      [Install]
      WantedBy=multi-user.target

  - path: /etc/continueplz-instance
    content: |
      PROVIDER={{ .Provider }}
      INSTANCE_ID={{ .InstanceID }}

  - path: /usr/local/bin/spot-interrupt-monitor.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      # Spot Interruption Monitor for continueplz
      # Monitors provider metadata service for termination notices
      # Serves interruption status via HTTP on port 51822

      PORT=51822
      PROVIDER="{{ .Provider }}"
      INTERRUPT_FILE="/tmp/continueplz-interrupted"
      LOG_FILE="/var/log/continueplz-spot-monitor.log"

      log() {
          echo "$(date -Iseconds) $1" >> "$LOG_FILE"
      }

      log "Starting spot interruption monitor for provider: $PROVIDER"

      # Provider-specific metadata service URLs and detection logic
      check_interruption() {
          case "$PROVIDER" in
              vast)
                  # Vast.ai uses file marker for interruption
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
              runpod)
                  # RunPod uses AWS-style metadata service for spot termination
                  TERMINATION_TIME=$(curl -sf --connect-timeout 2 \
                      http://169.254.169.254/latest/meta-data/spot/termination-time 2>/dev/null)
                  if [ -n "$TERMINATION_TIME" ] && [ "$TERMINATION_TIME" != "null" ]; then
                      echo "$TERMINATION_TIME" > /tmp/termination-time
                      return 0
                  fi
                  return 1
                  ;;
              coreweave)
                  # CoreWeave uses Kubernetes-style preemption notice
                  PREEMPTED=$(curl -sf --connect-timeout 2 \
                      http://169.254.169.254/v1/spot/preemption-notice 2>/dev/null)
                  if [ -n "$PREEMPTED" ] && [ "$PREEMPTED" != "null" ]; then
                      return 0
                  fi
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
              lambda|paperspace)
                  # Lambda and Paperspace don't support spot instances
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
              *)
                  if [ -f "$INTERRUPT_FILE" ]; then
                      return 0
                  fi
                  return 1
                  ;;
          esac
      }

      get_termination_time() {
          if [ -f /tmp/termination-time ]; then
              cat /tmp/termination-time
          else
              echo ""
          fi
      }

      get_reason() {
          case "$PROVIDER" in
              vast)
                  echo "capacity_reclaimed"
                  ;;
              runpod|coreweave)
                  echo "preempted"
                  ;;
              *)
                  echo "unknown"
                  ;;
          esac
      }

      # Background process to monitor for interruption
      (
          while true; do
              if check_interruption; then
                  if [ ! -f "$INTERRUPT_FILE" ]; then
                      TERMINATION_TIME=$(get_termination_time)
                      REASON=$(get_reason)
                      log "INTERRUPTION DETECTED: reason=$REASON termination_time=$TERMINATION_TIME"
                      echo "{\"reason\":\"$REASON\",\"termination_time\":\"$TERMINATION_TIME\"}" > "$INTERRUPT_FILE"
                  fi
              fi
              sleep 5
          done
      ) &
      MONITOR_PID=$!
      log "Background monitor started with PID: $MONITOR_PID"

      # HTTP server to serve interruption status
      while true; do
          if [ -f "$INTERRUPT_FILE" ]; then
              INTERRUPT_DATA=$(cat "$INTERRUPT_FILE")
              REASON=$(echo "$INTERRUPT_DATA" | jq -r '.reason // "unknown"' 2>/dev/null || echo "unknown")
              TERM_TIME=$(echo "$INTERRUPT_DATA" | jq -r '.termination_time // ""' 2>/dev/null || echo "")
              RESPONSE_BODY="{\"interrupted\":true,\"reason\":\"$REASON\",\"termination_time\":\"$TERM_TIME\",\"message\":\"Spot instance interruption detected\"}"
          else
              RESPONSE_BODY='{"interrupted":false}'
          fi

          CONTENT_LENGTH=$${#RESPONSE_BODY}
          RESPONSE="HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: $CONTENT_LENGTH\r\nConnection: close\r\n\r\n$RESPONSE_BODY"

          echo -e "$RESPONSE" | nc -l -p $PORT -q 1 2>/dev/null | while read line; do
              if echo "$line" | grep -q "GET /interrupt-status"; then
                  log "Received interrupt status request"
              fi
          done
      done

  - path: /etc/systemd/system/spot-interrupt-monitor.service
    content: |
      [Unit]
      Description=Continueplz Spot Interruption Monitor
      After=network.target wg-quick@wg0.service

      [Service]
      ExecStart=/usr/local/bin/spot-interrupt-monitor.sh
      Restart=always

      [Install]
      WantedBy=multi-user.target

runcmd:
  # Firewall
  - ufw default deny incoming
  - ufw default allow outgoing
  - ufw allow 51820/udp
  - ufw enable

  # WireGuard
  - systemctl enable wg-quick@wg0
  - systemctl start wg-quick@wg0

  # Allow Ollama and spot interrupt monitor only via WireGuard
  - ufw allow in on wg0 to any port 11434
  - ufw allow in on wg0 to any port 22
  - ufw allow in on wg0 to any port 51822

  # Docker setup
  - systemctl enable docker
  - systemctl start docker

  # NVIDIA Container Toolkit
  - curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg
  - curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | tee /etc/apt/sources.list.d/nvidia-container-toolkit.list
  - apt-get update
  - apt-get install -y nvidia-container-toolkit
  - nvidia-ctk runtime configure --runtime=docker
  - systemctl restart docker

  # Start Ollama
  - docker run -d --gpus all -v ollama:/root/.ollama -p 10.13.37.1:11434:11434 --name ollama --restart unless-stopped ollama/ollama

  # Wait and pull model
  - sleep 10
  - until curl -s http://10.13.37.1:11434/api/tags > /dev/null; do sleep 2; done
  - docker exec ollama ollama pull {{ .Model }}

  # Start deadman
  - systemctl enable deadman
  - systemctl start deadman

  # Start spot interrupt monitor
  - systemctl enable spot-interrupt-monitor
  - systemctl start spot-interrupt-monitor

  # Signal ready
  - touch /tmp/continueplz-ready
`

// GenerateCloudInit generates a cloud-init configuration from the given parameters.
// The output is valid YAML suitable for cloud-init.
func GenerateCloudInit(params *CloudInitParams) (string, error) {
	if params == nil {
		return "", fmt.Errorf("cloud-init params are nil")
	}

	if err := params.Validate(); err != nil {
		return "", fmt.Errorf("invalid cloud-init params: %w", err)
	}

	// Apply defaults if not set
	if params.WireGuard.ListenPort == 0 {
		params.WireGuard.ListenPort = wireguard.DefaultListenPort
	}
	if params.WireGuard.ServerAddress == "" {
		params.WireGuard.ServerAddress = wireguard.ServerAddress
	}
	if params.WireGuard.ClientAllowedIPs == "" {
		params.WireGuard.ClientAllowedIPs = wireguard.ClientAllowedIPs
	}
	if params.Deadman.TimeoutSeconds == 0 {
		params.Deadman.TimeoutSeconds = 36000 // 10 hours
	}

	// Normalize provider name to lowercase
	params.Provider = strings.ToLower(params.Provider)

	tmpl, err := template.New("cloudinit").Parse(cloudInitTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse cloud-init template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, params); err != nil {
		return "", fmt.Errorf("failed to execute cloud-init template: %w", err)
	}

	return buf.String(), nil
}

// GenerateCloudInitFromConfigPair generates a cloud-init configuration from a WireGuard ConfigPair.
// This is a convenience function that extracts the server configuration from the ConfigPair.
func GenerateCloudInitFromConfigPair(configPair *wireguard.ConfigPair, provider, instanceID, model, apiKey string, deadmanTimeoutSeconds int) (string, error) {
	if configPair == nil {
		return "", fmt.Errorf("config pair is nil")
	}
	if configPair.Server == nil {
		return "", fmt.Errorf("server config is nil")
	}

	params := CloudInitParamsFromServerConfig(configPair.Server, provider, instanceID, model, apiKey, deadmanTimeoutSeconds)
	return GenerateCloudInit(params)
}

// DeadmanTimeoutFromHours converts hours to seconds for the deadman timeout.
func DeadmanTimeoutFromHours(hours int) int {
	return hours * 3600
}

// DefaultDeadmanTimeoutSeconds is the default deadman timeout in seconds (10 hours).
const DefaultDeadmanTimeoutSeconds = 36000
